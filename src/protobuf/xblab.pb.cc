// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: xblab.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "xblab.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace xblab {

void protobuf_ShutdownFile_xblab_2eproto() {
  delete Broadcast::default_instance_;
  delete Broadcast_Session::default_instance_;
  delete Broadcast_Payload::default_instance_;
  delete Broadcast_Prologue::default_instance_;
  delete Broadcast_Error::default_instance_;
  delete Broadcast_No_Op::default_instance_;
  delete Broadcast_Data::default_instance_;
  delete Transmission::default_instance_;
  delete Transmission_Credential::default_instance_;
  delete Transmission_Payload::default_instance_;
  delete Transmission_Error::default_instance_;
  delete Transmission_No_Op::default_instance_;
  delete Transmission_Data::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_xblab_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_xblab_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  Broadcast::default_instance_ = new Broadcast();
  Broadcast_Session::default_instance_ = new Broadcast_Session();
  Broadcast_Payload::default_instance_ = new Broadcast_Payload();
  Broadcast_Prologue::default_instance_ = new Broadcast_Prologue();
  Broadcast_Error::default_instance_ = new Broadcast_Error();
  Broadcast_No_Op::default_instance_ = new Broadcast_No_Op();
  Broadcast_Data::default_instance_ = new Broadcast_Data();
  Transmission::default_instance_ = new Transmission();
  Transmission_Credential::default_instance_ = new Transmission_Credential();
  Transmission_Payload::default_instance_ = new Transmission_Payload();
  Transmission_Error::default_instance_ = new Transmission_Error();
  Transmission_No_Op::default_instance_ = new Transmission_No_Op();
  Transmission_Data::default_instance_ = new Transmission_Data();
  Broadcast::default_instance_->InitAsDefaultInstance();
  Broadcast_Session::default_instance_->InitAsDefaultInstance();
  Broadcast_Payload::default_instance_->InitAsDefaultInstance();
  Broadcast_Prologue::default_instance_->InitAsDefaultInstance();
  Broadcast_Error::default_instance_->InitAsDefaultInstance();
  Broadcast_No_Op::default_instance_->InitAsDefaultInstance();
  Broadcast_Data::default_instance_->InitAsDefaultInstance();
  Transmission::default_instance_->InitAsDefaultInstance();
  Transmission_Credential::default_instance_->InitAsDefaultInstance();
  Transmission_Payload::default_instance_->InitAsDefaultInstance();
  Transmission_Error::default_instance_->InitAsDefaultInstance();
  Transmission_No_Op::default_instance_->InitAsDefaultInstance();
  Transmission_Data::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_xblab_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_xblab_2eproto_once_);
void protobuf_AddDesc_xblab_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_xblab_2eproto_once_,
                 &protobuf_AddDesc_xblab_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_xblab_2eproto {
  StaticDescriptorInitializer_xblab_2eproto() {
    protobuf_AddDesc_xblab_2eproto();
  }
} static_descriptor_initializer_xblab_2eproto_;
#endif

// ===================================================================

bool Broadcast_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Broadcast_Type Broadcast::NEEDCRED;
const Broadcast_Type Broadcast::GROUPLIST;
const Broadcast_Type Broadcast::GROUPENTRY;
const Broadcast_Type Broadcast::BEGIN;
const Broadcast_Type Broadcast::BROADCAST;
const Broadcast_Type Broadcast::GROUPEXIT;
const Broadcast_Type Broadcast::QUIT;
const Broadcast_Type Broadcast::ERROR;
const Broadcast_Type Broadcast::NO_OP;
const Broadcast_Type Broadcast::Type_MIN;
const Broadcast_Type Broadcast::Type_MAX;
const int Broadcast::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Broadcast_Session::kPubKeyFieldNumber;
const int Broadcast_Session::kSeedFieldNumber;
#endif  // !_MSC_VER

Broadcast_Session::Broadcast_Session()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Broadcast_Session::InitAsDefaultInstance() {
}

Broadcast_Session::Broadcast_Session(const Broadcast_Session& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Broadcast_Session::SharedCtor() {
  _cached_size_ = 0;
  pub_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  seed_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Broadcast_Session::~Broadcast_Session() {
  SharedDtor();
}

void Broadcast_Session::SharedDtor() {
  if (pub_key_ != &::google::protobuf::internal::kEmptyString) {
    delete pub_key_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Broadcast_Session::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Broadcast_Session& Broadcast_Session::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_xblab_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_xblab_2eproto();
#endif
  return *default_instance_;
}

Broadcast_Session* Broadcast_Session::default_instance_ = NULL;

Broadcast_Session* Broadcast_Session::New() const {
  return new Broadcast_Session;
}

void Broadcast_Session::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_pub_key()) {
      if (pub_key_ != &::google::protobuf::internal::kEmptyString) {
        pub_key_->clear();
      }
    }
    seed_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Broadcast_Session::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string pub_key = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pub_key()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_seed;
        break;
      }

      // required fixed32 seed = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_seed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &seed_)));
          set_has_seed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Broadcast_Session::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string pub_key = 1;
  if (has_pub_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->pub_key(), output);
  }

  // required fixed32 seed = 2;
  if (has_seed()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(2, this->seed(), output);
  }

}

int Broadcast_Session::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string pub_key = 1;
    if (has_pub_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pub_key());
    }

    // required fixed32 seed = 2;
    if (has_seed()) {
      total_size += 1 + 4;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Broadcast_Session::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Broadcast_Session*>(&from));
}

void Broadcast_Session::MergeFrom(const Broadcast_Session& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pub_key()) {
      set_pub_key(from.pub_key());
    }
    if (from.has_seed()) {
      set_seed(from.seed());
    }
  }
}

void Broadcast_Session::CopyFrom(const Broadcast_Session& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Broadcast_Session::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Broadcast_Session::Swap(Broadcast_Session* other) {
  if (other != this) {
    std::swap(pub_key_, other->pub_key_);
    std::swap(seed_, other->seed_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Broadcast_Session::GetTypeName() const {
  return "xblab.Broadcast.Session";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Broadcast_Payload::kContentFieldNumber;
const int Broadcast_Payload::kModuloFieldNumber;
#endif  // !_MSC_VER

Broadcast_Payload::Broadcast_Payload()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Broadcast_Payload::InitAsDefaultInstance() {
}

Broadcast_Payload::Broadcast_Payload(const Broadcast_Payload& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Broadcast_Payload::SharedCtor() {
  _cached_size_ = 0;
  content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  modulo_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Broadcast_Payload::~Broadcast_Payload() {
  SharedDtor();
}

void Broadcast_Payload::SharedDtor() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Broadcast_Payload::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Broadcast_Payload& Broadcast_Payload::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_xblab_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_xblab_2eproto();
#endif
  return *default_instance_;
}

Broadcast_Payload* Broadcast_Payload::default_instance_ = NULL;

Broadcast_Payload* Broadcast_Payload::New() const {
  return new Broadcast_Payload;
}

void Broadcast_Payload::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_content()) {
      if (content_ != &::google::protobuf::internal::kEmptyString) {
        content_->clear();
      }
    }
    modulo_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Broadcast_Payload::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string content = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_content()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_modulo;
        break;
      }

      // required fixed32 modulo = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_modulo:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &modulo_)));
          set_has_modulo();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Broadcast_Payload::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string content = 1;
  if (has_content()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->content(), output);
  }

  // required fixed32 modulo = 2;
  if (has_modulo()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(2, this->modulo(), output);
  }

}

int Broadcast_Payload::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string content = 1;
    if (has_content()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->content());
    }

    // required fixed32 modulo = 2;
    if (has_modulo()) {
      total_size += 1 + 4;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Broadcast_Payload::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Broadcast_Payload*>(&from));
}

void Broadcast_Payload::MergeFrom(const Broadcast_Payload& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_content()) {
      set_content(from.content());
    }
    if (from.has_modulo()) {
      set_modulo(from.modulo());
    }
  }
}

void Broadcast_Payload::CopyFrom(const Broadcast_Payload& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Broadcast_Payload::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Broadcast_Payload::Swap(Broadcast_Payload* other) {
  if (other != this) {
    std::swap(content_, other->content_);
    std::swap(modulo_, other->modulo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Broadcast_Payload::GetTypeName() const {
  return "xblab.Broadcast.Payload";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Broadcast_Prologue::kModuloFieldNumber;
#endif  // !_MSC_VER

Broadcast_Prologue::Broadcast_Prologue()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Broadcast_Prologue::InitAsDefaultInstance() {
}

Broadcast_Prologue::Broadcast_Prologue(const Broadcast_Prologue& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Broadcast_Prologue::SharedCtor() {
  _cached_size_ = 0;
  modulo_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Broadcast_Prologue::~Broadcast_Prologue() {
  SharedDtor();
}

void Broadcast_Prologue::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Broadcast_Prologue::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Broadcast_Prologue& Broadcast_Prologue::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_xblab_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_xblab_2eproto();
#endif
  return *default_instance_;
}

Broadcast_Prologue* Broadcast_Prologue::default_instance_ = NULL;

Broadcast_Prologue* Broadcast_Prologue::New() const {
  return new Broadcast_Prologue;
}

void Broadcast_Prologue::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    modulo_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Broadcast_Prologue::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required fixed32 modulo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &modulo_)));
          set_has_modulo();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Broadcast_Prologue::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required fixed32 modulo = 1;
  if (has_modulo()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(1, this->modulo(), output);
  }

}

int Broadcast_Prologue::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required fixed32 modulo = 1;
    if (has_modulo()) {
      total_size += 1 + 4;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Broadcast_Prologue::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Broadcast_Prologue*>(&from));
}

void Broadcast_Prologue::MergeFrom(const Broadcast_Prologue& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_modulo()) {
      set_modulo(from.modulo());
    }
  }
}

void Broadcast_Prologue::CopyFrom(const Broadcast_Prologue& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Broadcast_Prologue::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Broadcast_Prologue::Swap(Broadcast_Prologue* other) {
  if (other != this) {
    std::swap(modulo_, other->modulo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Broadcast_Prologue::GetTypeName() const {
  return "xblab.Broadcast.Prologue";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Broadcast_Error::kWhatFieldNumber;
#endif  // !_MSC_VER

Broadcast_Error::Broadcast_Error()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Broadcast_Error::InitAsDefaultInstance() {
}

Broadcast_Error::Broadcast_Error(const Broadcast_Error& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Broadcast_Error::SharedCtor() {
  _cached_size_ = 0;
  what_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Broadcast_Error::~Broadcast_Error() {
  SharedDtor();
}

void Broadcast_Error::SharedDtor() {
  if (what_ != &::google::protobuf::internal::kEmptyString) {
    delete what_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Broadcast_Error::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Broadcast_Error& Broadcast_Error::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_xblab_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_xblab_2eproto();
#endif
  return *default_instance_;
}

Broadcast_Error* Broadcast_Error::default_instance_ = NULL;

Broadcast_Error* Broadcast_Error::New() const {
  return new Broadcast_Error;
}

void Broadcast_Error::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_what()) {
      if (what_ != &::google::protobuf::internal::kEmptyString) {
        what_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Broadcast_Error::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string what = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_what()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Broadcast_Error::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string what = 1;
  if (has_what()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->what(), output);
  }

}

int Broadcast_Error::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string what = 1;
    if (has_what()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->what());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Broadcast_Error::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Broadcast_Error*>(&from));
}

void Broadcast_Error::MergeFrom(const Broadcast_Error& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_what()) {
      set_what(from.what());
    }
  }
}

void Broadcast_Error::CopyFrom(const Broadcast_Error& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Broadcast_Error::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Broadcast_Error::Swap(Broadcast_Error* other) {
  if (other != this) {
    std::swap(what_, other->what_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Broadcast_Error::GetTypeName() const {
  return "xblab.Broadcast.Error";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Broadcast_No_Op::kWhatFieldNumber;
#endif  // !_MSC_VER

Broadcast_No_Op::Broadcast_No_Op()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Broadcast_No_Op::InitAsDefaultInstance() {
}

Broadcast_No_Op::Broadcast_No_Op(const Broadcast_No_Op& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Broadcast_No_Op::SharedCtor() {
  _cached_size_ = 0;
  what_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Broadcast_No_Op::~Broadcast_No_Op() {
  SharedDtor();
}

void Broadcast_No_Op::SharedDtor() {
  if (what_ != &::google::protobuf::internal::kEmptyString) {
    delete what_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Broadcast_No_Op::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Broadcast_No_Op& Broadcast_No_Op::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_xblab_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_xblab_2eproto();
#endif
  return *default_instance_;
}

Broadcast_No_Op* Broadcast_No_Op::default_instance_ = NULL;

Broadcast_No_Op* Broadcast_No_Op::New() const {
  return new Broadcast_No_Op;
}

void Broadcast_No_Op::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_what()) {
      if (what_ != &::google::protobuf::internal::kEmptyString) {
        what_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Broadcast_No_Op::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string what = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_what()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Broadcast_No_Op::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string what = 1;
  if (has_what()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->what(), output);
  }

}

int Broadcast_No_Op::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string what = 1;
    if (has_what()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->what());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Broadcast_No_Op::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Broadcast_No_Op*>(&from));
}

void Broadcast_No_Op::MergeFrom(const Broadcast_No_Op& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_what()) {
      set_what(from.what());
    }
  }
}

void Broadcast_No_Op::CopyFrom(const Broadcast_No_Op& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Broadcast_No_Op::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Broadcast_No_Op::Swap(Broadcast_No_Op* other) {
  if (other != this) {
    std::swap(what_, other->what_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Broadcast_No_Op::GetTypeName() const {
  return "xblab.Broadcast.No_Op";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Broadcast_Data::kTypeFieldNumber;
const int Broadcast_Data::kNonceFieldNumber;
const int Broadcast_Data::kReturnNonceFieldNumber;
const int Broadcast_Data::kSessionFieldNumber;
const int Broadcast_Data::kPrologueFieldNumber;
const int Broadcast_Data::kPayloadFieldNumber;
const int Broadcast_Data::kErrorFieldNumber;
const int Broadcast_Data::kNoOpFieldNumber;
#endif  // !_MSC_VER

Broadcast_Data::Broadcast_Data()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Broadcast_Data::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  session_ = const_cast< ::xblab::Broadcast_Session*>(
      ::xblab::Broadcast_Session::internal_default_instance());
#else
  session_ = const_cast< ::xblab::Broadcast_Session*>(&::xblab::Broadcast_Session::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  prologue_ = const_cast< ::xblab::Broadcast_Prologue*>(
      ::xblab::Broadcast_Prologue::internal_default_instance());
#else
  prologue_ = const_cast< ::xblab::Broadcast_Prologue*>(&::xblab::Broadcast_Prologue::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  payload_ = const_cast< ::xblab::Broadcast_Payload*>(
      ::xblab::Broadcast_Payload::internal_default_instance());
#else
  payload_ = const_cast< ::xblab::Broadcast_Payload*>(&::xblab::Broadcast_Payload::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  error_ = const_cast< ::xblab::Broadcast_Error*>(
      ::xblab::Broadcast_Error::internal_default_instance());
#else
  error_ = const_cast< ::xblab::Broadcast_Error*>(&::xblab::Broadcast_Error::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  no_op_ = const_cast< ::xblab::Broadcast_No_Op*>(
      ::xblab::Broadcast_No_Op::internal_default_instance());
#else
  no_op_ = const_cast< ::xblab::Broadcast_No_Op*>(&::xblab::Broadcast_No_Op::default_instance());
#endif
}

Broadcast_Data::Broadcast_Data(const Broadcast_Data& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Broadcast_Data::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  return_nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  session_ = NULL;
  prologue_ = NULL;
  payload_ = NULL;
  error_ = NULL;
  no_op_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Broadcast_Data::~Broadcast_Data() {
  SharedDtor();
}

void Broadcast_Data::SharedDtor() {
  if (nonce_ != &::google::protobuf::internal::kEmptyString) {
    delete nonce_;
  }
  if (return_nonce_ != &::google::protobuf::internal::kEmptyString) {
    delete return_nonce_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete session_;
    delete prologue_;
    delete payload_;
    delete error_;
    delete no_op_;
  }
}

void Broadcast_Data::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Broadcast_Data& Broadcast_Data::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_xblab_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_xblab_2eproto();
#endif
  return *default_instance_;
}

Broadcast_Data* Broadcast_Data::default_instance_ = NULL;

Broadcast_Data* Broadcast_Data::New() const {
  return new Broadcast_Data;
}

void Broadcast_Data::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    if (has_nonce()) {
      if (nonce_ != &::google::protobuf::internal::kEmptyString) {
        nonce_->clear();
      }
    }
    if (has_return_nonce()) {
      if (return_nonce_ != &::google::protobuf::internal::kEmptyString) {
        return_nonce_->clear();
      }
    }
    if (has_session()) {
      if (session_ != NULL) session_->::xblab::Broadcast_Session::Clear();
    }
    if (has_prologue()) {
      if (prologue_ != NULL) prologue_->::xblab::Broadcast_Prologue::Clear();
    }
    if (has_payload()) {
      if (payload_ != NULL) payload_->::xblab::Broadcast_Payload::Clear();
    }
    if (has_error()) {
      if (error_ != NULL) error_->::xblab::Broadcast_Error::Clear();
    }
    if (has_no_op()) {
      if (no_op_ != NULL) no_op_->::xblab::Broadcast_No_Op::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Broadcast_Data::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .xblab.Broadcast.Type type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::xblab::Broadcast_Type_IsValid(value)) {
            set_type(static_cast< ::xblab::Broadcast_Type >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_nonce;
        break;
      }

      // required string nonce = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_nonce:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_nonce()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_return_nonce;
        break;
      }

      // optional string return_nonce = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_return_nonce:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_return_nonce()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_session;
        break;
      }

      // optional .xblab.Broadcast.Session session = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_session:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_session()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_prologue;
        break;
      }

      // optional .xblab.Broadcast.Prologue prologue = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_prologue:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_prologue()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_payload;
        break;
      }

      // optional .xblab.Broadcast.Payload payload = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_payload:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_payload()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_error;
        break;
      }

      // optional .xblab.Broadcast.Error error = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_error:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_error()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_no_op;
        break;
      }

      // optional .xblab.Broadcast.No_Op no_op = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_no_op:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_no_op()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Broadcast_Data::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .xblab.Broadcast.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // required string nonce = 2;
  if (has_nonce()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->nonce(), output);
  }

  // optional string return_nonce = 3;
  if (has_return_nonce()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->return_nonce(), output);
  }

  // optional .xblab.Broadcast.Session session = 4;
  if (has_session()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->session(), output);
  }

  // optional .xblab.Broadcast.Prologue prologue = 5;
  if (has_prologue()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->prologue(), output);
  }

  // optional .xblab.Broadcast.Payload payload = 6;
  if (has_payload()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->payload(), output);
  }

  // optional .xblab.Broadcast.Error error = 7;
  if (has_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->error(), output);
  }

  // optional .xblab.Broadcast.No_Op no_op = 8;
  if (has_no_op()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->no_op(), output);
  }

}

int Broadcast_Data::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .xblab.Broadcast.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // required string nonce = 2;
    if (has_nonce()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->nonce());
    }

    // optional string return_nonce = 3;
    if (has_return_nonce()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->return_nonce());
    }

    // optional .xblab.Broadcast.Session session = 4;
    if (has_session()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->session());
    }

    // optional .xblab.Broadcast.Prologue prologue = 5;
    if (has_prologue()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->prologue());
    }

    // optional .xblab.Broadcast.Payload payload = 6;
    if (has_payload()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->payload());
    }

    // optional .xblab.Broadcast.Error error = 7;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->error());
    }

    // optional .xblab.Broadcast.No_Op no_op = 8;
    if (has_no_op()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->no_op());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Broadcast_Data::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Broadcast_Data*>(&from));
}

void Broadcast_Data::MergeFrom(const Broadcast_Data& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_nonce()) {
      set_nonce(from.nonce());
    }
    if (from.has_return_nonce()) {
      set_return_nonce(from.return_nonce());
    }
    if (from.has_session()) {
      mutable_session()->::xblab::Broadcast_Session::MergeFrom(from.session());
    }
    if (from.has_prologue()) {
      mutable_prologue()->::xblab::Broadcast_Prologue::MergeFrom(from.prologue());
    }
    if (from.has_payload()) {
      mutable_payload()->::xblab::Broadcast_Payload::MergeFrom(from.payload());
    }
    if (from.has_error()) {
      mutable_error()->::xblab::Broadcast_Error::MergeFrom(from.error());
    }
    if (from.has_no_op()) {
      mutable_no_op()->::xblab::Broadcast_No_Op::MergeFrom(from.no_op());
    }
  }
}

void Broadcast_Data::CopyFrom(const Broadcast_Data& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Broadcast_Data::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_session()) {
    if (!this->session().IsInitialized()) return false;
  }
  if (has_prologue()) {
    if (!this->prologue().IsInitialized()) return false;
  }
  if (has_payload()) {
    if (!this->payload().IsInitialized()) return false;
  }
  if (has_error()) {
    if (!this->error().IsInitialized()) return false;
  }
  if (has_no_op()) {
    if (!this->no_op().IsInitialized()) return false;
  }
  return true;
}

void Broadcast_Data::Swap(Broadcast_Data* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(nonce_, other->nonce_);
    std::swap(return_nonce_, other->return_nonce_);
    std::swap(session_, other->session_);
    std::swap(prologue_, other->prologue_);
    std::swap(payload_, other->payload_);
    std::swap(error_, other->error_);
    std::swap(no_op_, other->no_op_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Broadcast_Data::GetTypeName() const {
  return "xblab.Broadcast.Data";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Broadcast::kSignatureFieldNumber;
const int Broadcast::kDataFieldNumber;
#endif  // !_MSC_VER

Broadcast::Broadcast()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Broadcast::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  data_ = const_cast< ::xblab::Broadcast_Data*>(
      ::xblab::Broadcast_Data::internal_default_instance());
#else
  data_ = const_cast< ::xblab::Broadcast_Data*>(&::xblab::Broadcast_Data::default_instance());
#endif
}

Broadcast::Broadcast(const Broadcast& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Broadcast::SharedCtor() {
  _cached_size_ = 0;
  signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  data_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Broadcast::~Broadcast() {
  SharedDtor();
}

void Broadcast::SharedDtor() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete data_;
  }
}

void Broadcast::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Broadcast& Broadcast::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_xblab_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_xblab_2eproto();
#endif
  return *default_instance_;
}

Broadcast* Broadcast::default_instance_ = NULL;

Broadcast* Broadcast::New() const {
  return new Broadcast;
}

void Broadcast::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_signature()) {
      if (signature_ != &::google::protobuf::internal::kEmptyString) {
        signature_->clear();
      }
    }
    if (has_data()) {
      if (data_ != NULL) data_->::xblab::Broadcast_Data::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Broadcast::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string signature = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_signature()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_data;
        break;
      }

      // required .xblab.Broadcast.Data data = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Broadcast::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string signature = 1;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->signature(), output);
  }

  // required .xblab.Broadcast.Data data = 2;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->data(), output);
  }

}

int Broadcast::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string signature = 1;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->signature());
    }

    // required .xblab.Broadcast.Data data = 2;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->data());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Broadcast::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Broadcast*>(&from));
}

void Broadcast::MergeFrom(const Broadcast& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_signature()) {
      set_signature(from.signature());
    }
    if (from.has_data()) {
      mutable_data()->::xblab::Broadcast_Data::MergeFrom(from.data());
    }
  }
}

void Broadcast::CopyFrom(const Broadcast& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Broadcast::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_data()) {
    if (!this->data().IsInitialized()) return false;
  }
  return true;
}

void Broadcast::Swap(Broadcast* other) {
  if (other != this) {
    std::swap(signature_, other->signature_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Broadcast::GetTypeName() const {
  return "xblab.Broadcast";
}


// ===================================================================

bool Transmission_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Transmission_Type Transmission::CRED;
const Transmission_Type Transmission::ENTER;
const Transmission_Type Transmission::TRANSMIT;
const Transmission_Type Transmission::EXIT;
const Transmission_Type Transmission::QUIT;
const Transmission_Type Transmission::ERROR;
const Transmission_Type Transmission::NO_OP;
const Transmission_Type Transmission::Type_MIN;
const Transmission_Type Transmission::Type_MAX;
const int Transmission::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Transmission_Credential::kUsernameFieldNumber;
const int Transmission_Credential::kPasswordFieldNumber;
const int Transmission_Credential::kGroupFieldNumber;
const int Transmission_Credential::kPubKeyFieldNumber;
#endif  // !_MSC_VER

Transmission_Credential::Transmission_Credential()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Transmission_Credential::InitAsDefaultInstance() {
}

Transmission_Credential::Transmission_Credential(const Transmission_Credential& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Transmission_Credential::SharedCtor() {
  _cached_size_ = 0;
  username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  group_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  pub_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Transmission_Credential::~Transmission_Credential() {
  SharedDtor();
}

void Transmission_Credential::SharedDtor() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (group_ != &::google::protobuf::internal::kEmptyString) {
    delete group_;
  }
  if (pub_key_ != &::google::protobuf::internal::kEmptyString) {
    delete pub_key_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Transmission_Credential::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Transmission_Credential& Transmission_Credential::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_xblab_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_xblab_2eproto();
#endif
  return *default_instance_;
}

Transmission_Credential* Transmission_Credential::default_instance_ = NULL;

Transmission_Credential* Transmission_Credential::New() const {
  return new Transmission_Credential;
}

void Transmission_Credential::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_username()) {
      if (username_ != &::google::protobuf::internal::kEmptyString) {
        username_->clear();
      }
    }
    if (has_password()) {
      if (password_ != &::google::protobuf::internal::kEmptyString) {
        password_->clear();
      }
    }
    if (has_group()) {
      if (group_ != &::google::protobuf::internal::kEmptyString) {
        group_->clear();
      }
    }
    if (has_pub_key()) {
      if (pub_key_ != &::google::protobuf::internal::kEmptyString) {
        pub_key_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Transmission_Credential::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string username = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_username()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_password;
        break;
      }

      // required string password = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_password:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_password()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_group;
        break;
      }

      // optional string group = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_group:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_group()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_pub_key;
        break;
      }

      // required string pub_key = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pub_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pub_key()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Transmission_Credential::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string username = 1;
  if (has_username()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->username(), output);
  }

  // required string password = 2;
  if (has_password()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->password(), output);
  }

  // optional string group = 3;
  if (has_group()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->group(), output);
  }

  // required string pub_key = 4;
  if (has_pub_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->pub_key(), output);
  }

}

int Transmission_Credential::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string username = 1;
    if (has_username()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->username());
    }

    // required string password = 2;
    if (has_password()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->password());
    }

    // optional string group = 3;
    if (has_group()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->group());
    }

    // required string pub_key = 4;
    if (has_pub_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pub_key());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Transmission_Credential::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Transmission_Credential*>(&from));
}

void Transmission_Credential::MergeFrom(const Transmission_Credential& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_username()) {
      set_username(from.username());
    }
    if (from.has_password()) {
      set_password(from.password());
    }
    if (from.has_group()) {
      set_group(from.group());
    }
    if (from.has_pub_key()) {
      set_pub_key(from.pub_key());
    }
  }
}

void Transmission_Credential::CopyFrom(const Transmission_Credential& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Transmission_Credential::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000b) != 0x0000000b) return false;

  return true;
}

void Transmission_Credential::Swap(Transmission_Credential* other) {
  if (other != this) {
    std::swap(username_, other->username_);
    std::swap(password_, other->password_);
    std::swap(group_, other->group_);
    std::swap(pub_key_, other->pub_key_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Transmission_Credential::GetTypeName() const {
  return "xblab.Transmission.Credential";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Transmission_Payload::kIsImportantFieldNumber;
const int Transmission_Payload::kContentFieldNumber;
#endif  // !_MSC_VER

Transmission_Payload::Transmission_Payload()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Transmission_Payload::InitAsDefaultInstance() {
}

Transmission_Payload::Transmission_Payload(const Transmission_Payload& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Transmission_Payload::SharedCtor() {
  _cached_size_ = 0;
  is_important_ = false;
  content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Transmission_Payload::~Transmission_Payload() {
  SharedDtor();
}

void Transmission_Payload::SharedDtor() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Transmission_Payload::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Transmission_Payload& Transmission_Payload::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_xblab_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_xblab_2eproto();
#endif
  return *default_instance_;
}

Transmission_Payload* Transmission_Payload::default_instance_ = NULL;

Transmission_Payload* Transmission_Payload::New() const {
  return new Transmission_Payload;
}

void Transmission_Payload::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    is_important_ = false;
    if (has_content()) {
      if (content_ != &::google::protobuf::internal::kEmptyString) {
        content_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Transmission_Payload::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool is_important = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_important_)));
          set_has_is_important();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_content;
        break;
      }

      // required string content = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_content:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_content()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Transmission_Payload::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool is_important = 1;
  if (has_is_important()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->is_important(), output);
  }

  // required string content = 2;
  if (has_content()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->content(), output);
  }

}

int Transmission_Payload::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool is_important = 1;
    if (has_is_important()) {
      total_size += 1 + 1;
    }

    // required string content = 2;
    if (has_content()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->content());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Transmission_Payload::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Transmission_Payload*>(&from));
}

void Transmission_Payload::MergeFrom(const Transmission_Payload& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_is_important()) {
      set_is_important(from.is_important());
    }
    if (from.has_content()) {
      set_content(from.content());
    }
  }
}

void Transmission_Payload::CopyFrom(const Transmission_Payload& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Transmission_Payload::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Transmission_Payload::Swap(Transmission_Payload* other) {
  if (other != this) {
    std::swap(is_important_, other->is_important_);
    std::swap(content_, other->content_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Transmission_Payload::GetTypeName() const {
  return "xblab.Transmission.Payload";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Transmission_Error::kWhatFieldNumber;
#endif  // !_MSC_VER

Transmission_Error::Transmission_Error()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Transmission_Error::InitAsDefaultInstance() {
}

Transmission_Error::Transmission_Error(const Transmission_Error& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Transmission_Error::SharedCtor() {
  _cached_size_ = 0;
  what_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Transmission_Error::~Transmission_Error() {
  SharedDtor();
}

void Transmission_Error::SharedDtor() {
  if (what_ != &::google::protobuf::internal::kEmptyString) {
    delete what_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Transmission_Error::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Transmission_Error& Transmission_Error::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_xblab_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_xblab_2eproto();
#endif
  return *default_instance_;
}

Transmission_Error* Transmission_Error::default_instance_ = NULL;

Transmission_Error* Transmission_Error::New() const {
  return new Transmission_Error;
}

void Transmission_Error::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_what()) {
      if (what_ != &::google::protobuf::internal::kEmptyString) {
        what_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Transmission_Error::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string what = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_what()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Transmission_Error::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string what = 1;
  if (has_what()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->what(), output);
  }

}

int Transmission_Error::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string what = 1;
    if (has_what()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->what());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Transmission_Error::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Transmission_Error*>(&from));
}

void Transmission_Error::MergeFrom(const Transmission_Error& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_what()) {
      set_what(from.what());
    }
  }
}

void Transmission_Error::CopyFrom(const Transmission_Error& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Transmission_Error::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Transmission_Error::Swap(Transmission_Error* other) {
  if (other != this) {
    std::swap(what_, other->what_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Transmission_Error::GetTypeName() const {
  return "xblab.Transmission.Error";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Transmission_No_Op::kWhatFieldNumber;
#endif  // !_MSC_VER

Transmission_No_Op::Transmission_No_Op()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Transmission_No_Op::InitAsDefaultInstance() {
}

Transmission_No_Op::Transmission_No_Op(const Transmission_No_Op& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Transmission_No_Op::SharedCtor() {
  _cached_size_ = 0;
  what_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Transmission_No_Op::~Transmission_No_Op() {
  SharedDtor();
}

void Transmission_No_Op::SharedDtor() {
  if (what_ != &::google::protobuf::internal::kEmptyString) {
    delete what_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Transmission_No_Op::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Transmission_No_Op& Transmission_No_Op::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_xblab_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_xblab_2eproto();
#endif
  return *default_instance_;
}

Transmission_No_Op* Transmission_No_Op::default_instance_ = NULL;

Transmission_No_Op* Transmission_No_Op::New() const {
  return new Transmission_No_Op;
}

void Transmission_No_Op::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_what()) {
      if (what_ != &::google::protobuf::internal::kEmptyString) {
        what_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Transmission_No_Op::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string what = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_what()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Transmission_No_Op::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string what = 1;
  if (has_what()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->what(), output);
  }

}

int Transmission_No_Op::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string what = 1;
    if (has_what()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->what());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Transmission_No_Op::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Transmission_No_Op*>(&from));
}

void Transmission_No_Op::MergeFrom(const Transmission_No_Op& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_what()) {
      set_what(from.what());
    }
  }
}

void Transmission_No_Op::CopyFrom(const Transmission_No_Op& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Transmission_No_Op::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Transmission_No_Op::Swap(Transmission_No_Op* other) {
  if (other != this) {
    std::swap(what_, other->what_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Transmission_No_Op::GetTypeName() const {
  return "xblab.Transmission.No_Op";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Transmission_Data::kTypeFieldNumber;
const int Transmission_Data::kNonceFieldNumber;
const int Transmission_Data::kReturnNonceFieldNumber;
const int Transmission_Data::kCredentialFieldNumber;
const int Transmission_Data::kPayloadFieldNumber;
const int Transmission_Data::kErrorFieldNumber;
const int Transmission_Data::kNoOpFieldNumber;
#endif  // !_MSC_VER

Transmission_Data::Transmission_Data()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Transmission_Data::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  credential_ = const_cast< ::xblab::Transmission_Credential*>(
      ::xblab::Transmission_Credential::internal_default_instance());
#else
  credential_ = const_cast< ::xblab::Transmission_Credential*>(&::xblab::Transmission_Credential::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  payload_ = const_cast< ::xblab::Transmission_Payload*>(
      ::xblab::Transmission_Payload::internal_default_instance());
#else
  payload_ = const_cast< ::xblab::Transmission_Payload*>(&::xblab::Transmission_Payload::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  error_ = const_cast< ::xblab::Transmission_Error*>(
      ::xblab::Transmission_Error::internal_default_instance());
#else
  error_ = const_cast< ::xblab::Transmission_Error*>(&::xblab::Transmission_Error::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  no_op_ = const_cast< ::xblab::Transmission_No_Op*>(
      ::xblab::Transmission_No_Op::internal_default_instance());
#else
  no_op_ = const_cast< ::xblab::Transmission_No_Op*>(&::xblab::Transmission_No_Op::default_instance());
#endif
}

Transmission_Data::Transmission_Data(const Transmission_Data& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Transmission_Data::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  return_nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  credential_ = NULL;
  payload_ = NULL;
  error_ = NULL;
  no_op_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Transmission_Data::~Transmission_Data() {
  SharedDtor();
}

void Transmission_Data::SharedDtor() {
  if (nonce_ != &::google::protobuf::internal::kEmptyString) {
    delete nonce_;
  }
  if (return_nonce_ != &::google::protobuf::internal::kEmptyString) {
    delete return_nonce_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete credential_;
    delete payload_;
    delete error_;
    delete no_op_;
  }
}

void Transmission_Data::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Transmission_Data& Transmission_Data::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_xblab_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_xblab_2eproto();
#endif
  return *default_instance_;
}

Transmission_Data* Transmission_Data::default_instance_ = NULL;

Transmission_Data* Transmission_Data::New() const {
  return new Transmission_Data;
}

void Transmission_Data::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    if (has_nonce()) {
      if (nonce_ != &::google::protobuf::internal::kEmptyString) {
        nonce_->clear();
      }
    }
    if (has_return_nonce()) {
      if (return_nonce_ != &::google::protobuf::internal::kEmptyString) {
        return_nonce_->clear();
      }
    }
    if (has_credential()) {
      if (credential_ != NULL) credential_->::xblab::Transmission_Credential::Clear();
    }
    if (has_payload()) {
      if (payload_ != NULL) payload_->::xblab::Transmission_Payload::Clear();
    }
    if (has_error()) {
      if (error_ != NULL) error_->::xblab::Transmission_Error::Clear();
    }
    if (has_no_op()) {
      if (no_op_ != NULL) no_op_->::xblab::Transmission_No_Op::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Transmission_Data::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .xblab.Transmission.Type type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::xblab::Transmission_Type_IsValid(value)) {
            set_type(static_cast< ::xblab::Transmission_Type >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_nonce;
        break;
      }

      // required string nonce = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_nonce:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_nonce()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_return_nonce;
        break;
      }

      // optional string return_nonce = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_return_nonce:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_return_nonce()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_credential;
        break;
      }

      // optional .xblab.Transmission.Credential credential = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_credential:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_credential()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_payload;
        break;
      }

      // optional .xblab.Transmission.Payload payload = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_payload:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_payload()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_error;
        break;
      }

      // optional .xblab.Transmission.Error error = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_error:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_error()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_no_op;
        break;
      }

      // optional .xblab.Transmission.No_Op no_op = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_no_op:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_no_op()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Transmission_Data::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .xblab.Transmission.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // required string nonce = 2;
  if (has_nonce()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->nonce(), output);
  }

  // optional string return_nonce = 3;
  if (has_return_nonce()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->return_nonce(), output);
  }

  // optional .xblab.Transmission.Credential credential = 4;
  if (has_credential()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->credential(), output);
  }

  // optional .xblab.Transmission.Payload payload = 5;
  if (has_payload()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->payload(), output);
  }

  // optional .xblab.Transmission.Error error = 6;
  if (has_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->error(), output);
  }

  // optional .xblab.Transmission.No_Op no_op = 7;
  if (has_no_op()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->no_op(), output);
  }

}

int Transmission_Data::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .xblab.Transmission.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // required string nonce = 2;
    if (has_nonce()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->nonce());
    }

    // optional string return_nonce = 3;
    if (has_return_nonce()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->return_nonce());
    }

    // optional .xblab.Transmission.Credential credential = 4;
    if (has_credential()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->credential());
    }

    // optional .xblab.Transmission.Payload payload = 5;
    if (has_payload()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->payload());
    }

    // optional .xblab.Transmission.Error error = 6;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->error());
    }

    // optional .xblab.Transmission.No_Op no_op = 7;
    if (has_no_op()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->no_op());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Transmission_Data::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Transmission_Data*>(&from));
}

void Transmission_Data::MergeFrom(const Transmission_Data& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_nonce()) {
      set_nonce(from.nonce());
    }
    if (from.has_return_nonce()) {
      set_return_nonce(from.return_nonce());
    }
    if (from.has_credential()) {
      mutable_credential()->::xblab::Transmission_Credential::MergeFrom(from.credential());
    }
    if (from.has_payload()) {
      mutable_payload()->::xblab::Transmission_Payload::MergeFrom(from.payload());
    }
    if (from.has_error()) {
      mutable_error()->::xblab::Transmission_Error::MergeFrom(from.error());
    }
    if (from.has_no_op()) {
      mutable_no_op()->::xblab::Transmission_No_Op::MergeFrom(from.no_op());
    }
  }
}

void Transmission_Data::CopyFrom(const Transmission_Data& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Transmission_Data::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_credential()) {
    if (!this->credential().IsInitialized()) return false;
  }
  if (has_payload()) {
    if (!this->payload().IsInitialized()) return false;
  }
  if (has_error()) {
    if (!this->error().IsInitialized()) return false;
  }
  if (has_no_op()) {
    if (!this->no_op().IsInitialized()) return false;
  }
  return true;
}

void Transmission_Data::Swap(Transmission_Data* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(nonce_, other->nonce_);
    std::swap(return_nonce_, other->return_nonce_);
    std::swap(credential_, other->credential_);
    std::swap(payload_, other->payload_);
    std::swap(error_, other->error_);
    std::swap(no_op_, other->no_op_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Transmission_Data::GetTypeName() const {
  return "xblab.Transmission.Data";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Transmission::kSignatureFieldNumber;
const int Transmission::kDataFieldNumber;
#endif  // !_MSC_VER

Transmission::Transmission()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Transmission::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  data_ = const_cast< ::xblab::Transmission_Data*>(
      ::xblab::Transmission_Data::internal_default_instance());
#else
  data_ = const_cast< ::xblab::Transmission_Data*>(&::xblab::Transmission_Data::default_instance());
#endif
}

Transmission::Transmission(const Transmission& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Transmission::SharedCtor() {
  _cached_size_ = 0;
  signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  data_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Transmission::~Transmission() {
  SharedDtor();
}

void Transmission::SharedDtor() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete data_;
  }
}

void Transmission::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Transmission& Transmission::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_xblab_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_xblab_2eproto();
#endif
  return *default_instance_;
}

Transmission* Transmission::default_instance_ = NULL;

Transmission* Transmission::New() const {
  return new Transmission;
}

void Transmission::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_signature()) {
      if (signature_ != &::google::protobuf::internal::kEmptyString) {
        signature_->clear();
      }
    }
    if (has_data()) {
      if (data_ != NULL) data_->::xblab::Transmission_Data::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Transmission::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string signature = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_signature()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_data;
        break;
      }

      // required .xblab.Transmission.Data data = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Transmission::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string signature = 1;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->signature(), output);
  }

  // required .xblab.Transmission.Data data = 2;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->data(), output);
  }

}

int Transmission::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string signature = 1;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->signature());
    }

    // required .xblab.Transmission.Data data = 2;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->data());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Transmission::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Transmission*>(&from));
}

void Transmission::MergeFrom(const Transmission& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_signature()) {
      set_signature(from.signature());
    }
    if (from.has_data()) {
      mutable_data()->::xblab::Transmission_Data::MergeFrom(from.data());
    }
  }
}

void Transmission::CopyFrom(const Transmission& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Transmission::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_data()) {
    if (!this->data().IsInitialized()) return false;
  }
  return true;
}

void Transmission::Swap(Transmission* other) {
  if (other != this) {
    std::swap(signature_, other->signature_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Transmission::GetTypeName() const {
  return "xblab.Transmission";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace xblab

// @@protoc_insertion_point(global_scope)
